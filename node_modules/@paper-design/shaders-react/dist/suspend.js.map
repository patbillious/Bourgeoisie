{
  "version": 3,
  "sources": ["../src/suspend.tsx"],
  "sourcesContent": ["/**\n * A cut down version of suspend-react.\n * When paper-shaders only supports React 19+ we can use the use hook instead.\n */\n\ntype Tuple<T = any> = [T] | T[];\ntype Await<T> = T extends Promise<infer V> ? V : never;\ntype Cache<Keys extends Tuple<unknown>> = {\n  promise: Promise<unknown>;\n  keys: Keys;\n  error?: any;\n  response?: unknown;\n};\n\nconst isPromise = (promise: any): promise is Promise<unknown> =>\n  typeof promise === 'object' && typeof (promise as Promise<any>).then === 'function';\n\nconst globalCache: Cache<Tuple<unknown>>[] = [];\n\nfunction shallowEqualArrays(arrA: any[], arrB: any[]) {\n  if (arrA === arrB) return true;\n  if (!arrA || !arrB) return false;\n  const len = arrA.length;\n  if (arrB.length !== len) return false;\n  for (let i = 0; i < len; i++) if (arrA[i] !== arrB[i]) return false;\n  return true;\n}\n\nfunction query<Keys extends Tuple<unknown>, Fn extends (...keys: Keys) => Promise<unknown>>(\n  fn: Fn | Promise<unknown>,\n  keys: Keys = null as unknown as Keys\n) {\n  // If no keys were given, the function is the key\n  if (keys === null) keys = [fn] as unknown as Keys;\n\n  for (const entry of globalCache) {\n    // Find a match\n    if (shallowEqualArrays(keys, entry.keys)) {\n      // If an error occurred, throw\n      if (Object.prototype.hasOwnProperty.call(entry, 'error')) throw entry.error;\n      // If a response was successful, return\n      if (Object.prototype.hasOwnProperty.call(entry, 'response')) {\n        return entry.response as Await<ReturnType<Fn>>;\n      }\n      // If the promise is still unresolved, throw\n      throw entry.promise;\n    }\n  }\n\n  // The request is new or has changed.\n  const entry: Cache<Keys> = {\n    keys,\n    promise:\n      // Execute the promise\n      (isPromise(fn) ? fn : fn(...keys))\n        // When it resolves, store its value\n        .then((response) => {\n          entry.response = response;\n        })\n        // Store caught errors, they will be thrown in the render-phase to bubble into an error-bound\n        .catch((error) => (entry.error = error)),\n  };\n  // Register the entry\n  globalCache.push(entry);\n  // And throw the promise, this yields control back to React\n  throw entry.promise;\n}\n\nconst suspend = <Keys extends Tuple<unknown>, Fn extends (...keys: Keys) => Promise<unknown>>(\n  fn: Fn | Promise<unknown>,\n  keys?: Keys\n): Await<ReturnType<Fn>> => query(fn, keys);\n\nexport { suspend };\n"],
  "mappings": ";;;;;AAcA,MAAM,YAAY,CAAC,YACjB,OAAO,YAAY,YAAY,OAAQ,QAAyB,SAAS;AAE3E,MAAM,cAAuC,CAAC;AAE9C,SAAS,mBAAmB,MAAa,MAAa;AACpD,MAAI,SAAS,KAAM,QAAO;AAC1B,MAAI,CAAC,QAAQ,CAAC,KAAM,QAAO;AAC3B,QAAM,MAAM,KAAK;AACjB,MAAI,KAAK,WAAW,IAAK,QAAO;AAChC,WAAS,IAAI,GAAG,IAAI,KAAK,IAAK,KAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAG,QAAO;AAC9D,SAAO;AACT;AAEA,SAAS,MACP,IACA,OAAa,MACb;AAEA,MAAI,SAAS,KAAM,QAAO,CAAC,EAAE;AAE7B,aAAWA,UAAS,aAAa;AAE/B,QAAI,mBAAmB,MAAMA,OAAM,IAAI,GAAG;AAExC,UAAI,OAAO,UAAU,eAAe,KAAKA,QAAO,OAAO,EAAG,OAAMA,OAAM;AAEtE,UAAI,OAAO,UAAU,eAAe,KAAKA,QAAO,UAAU,GAAG;AAC3D,eAAOA,OAAM;AAAA,MACf;AAEA,YAAMA,OAAM;AAAA,IACd;AAAA,EACF;AAGA,QAAM,QAAqB;AAAA,IACzB;AAAA,IACA;AAAA;AAAA,OAEG,UAAU,EAAE,IAAI,KAAK,GAAG,GAAG,IAAI,GAE7B,KAAK,CAAC,aAAa;AAClB,cAAM,WAAW;AAAA,MACnB,CAAC,EAEA,MAAM,CAAC,UAAW,MAAM,QAAQ,KAAM;AAAA;AAAA,EAC7C;AAEA,cAAY,KAAK,KAAK;AAEtB,QAAM,MAAM;AACd;AAEA,MAAM,UAAU,CACd,IACA,SAC0B,MAAM,IAAI,IAAI;",
  "names": ["entry"]
}
